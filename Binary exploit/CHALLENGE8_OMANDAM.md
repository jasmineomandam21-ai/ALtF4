JASMINE C. OMANDAM  
[picoCTF \- picoGym Challenges](https://play.picoctf.org/practice/challenge/438?category=6&page=1)

# **Write-Up: HEAP 0**

When I started the heap0 challenge, the program displayed two variables allocated on the heap. One was my writable buffer, and the other was safe\_var. The objective became clear after observing the menu: if safe\_var contained the string "pico", the program would print the flag. Initially, safe\_var was set to "bico", so the goal was to overwrite it using a heap overflow vulnerability.

### **Step 1: Exploring the Heap**

I first printed the heap state and saw:

0x...52b0  \-\> pico   
0x...52d0  \-\> bico

I noticed that the addresses were very close to each other. Calculating the difference:

0x52d0 \- 0x52b0 \= 0x20 \= 32 bytes

This meant that safe\_var was located exactly 32 bytes after my buffer in memory. That suggested that if I wrote more than 32 bytes into my buffer, I could overflow into safe\_var.

### **Step 2: First Attempts**

I initially tried shorter payloads like:

AAAAAApico

After printing the heap again, I saw that only my buffer changed, while safe\_var remained "bico". This confirmed that the input was not long enough to reach the adjacent heap chunk.

### **Step 3: Adjusting the Offset**

Since the memory difference was 32 bytes, I crafted a payload with exactly 32 padding characters before "pico":

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAApico

This consisted of:

* 32 As

* Followed by "pico"

### **Step 4: Successful Overwrite**

After submitting the payload and printing the heap again, the result showed:

0x...52b0  \-\> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAApico   
0x...52d0  \-\> pico

This confirmed that the overflow successfully modified safe\_var from "bico" to "pico".

### **Step 5: Printing the Flag**

With safe\_var overwritten correctly, I selected option 4\. The program responded:

**YOU WIN**   
**picoCTF{my\_first\_heap\_overflow\_0c473fe8}**

### **Reflection**

As a student, this challenge strengthened my understanding of how heap memory works. Before solving it, I thought heap vulnerabilities were more complicated, but this showed me that careful observation and simple arithmetic can reveal everything needed for exploitation. Calculating the exact 32-byte offset made the attack precise rather than random. One of the main challenges I faced was understanding why my first payload did not work. At first, I assumed that simply adding "pico" after a few characters would overwrite safe\_var. However, when I checked the heap state again, safe\_var remained unchanged. That made me realize that exploitation is not about guessing   it requires precise calculation.

