Day 1 – SQL Injection

In the SQL Injection lab, I entered the payload 1' OR '1'='1' # into the User ID field. The application failed to sanitize the input and directly included it in the SQL query. Because the condition '1'='1' is always true, the database returned all user records instead of a single user. This demonstrates how improper input validation can lead to SQL Injection vulnerabilities and unauthorized data access.

Day 2 – Reflected XSS

In the Reflected XSS lab, I entered the payload <script>alert(1)</script> into the input field. The application reflected the input directly into the page without sanitizing it. As a result, the browser executed the injected JavaScript and displayed an alert popup. This demonstrates how reflected XSS vulnerabilities allow attackers to inject and execute malicious scripts in a user’s browser.

Day 3 – Stored XSS (Basic Injection)

In the Stored XSS lab, I injected the payload <script>alert('XSS')</script> into the guestbook message field. The application stored the malicious script in the database and displayed it without sanitization. As a result, the JavaScript executed automatically whenever the page loaded. This demonstrates how stored XSS can persist in the system and affect multiple users.

Day 5 – Stored XSS (Cookie Access)

In the Stored XSS lab, I injected the payload <script>alert(document.cookie)</script>. The browser executed the script and displayed the session cookie. This demonstrates how attackers can access sensitive session data through XSS vulnerabilities. In real-world scenarios, attackers could send stolen cookies to an external server and hijack user sessions.

Day 6 – Stored XSS (Phishing Simulation)

In the Stored XSS lab, I injected a fake login form using HTML code. The application stored and displayed the malicious content without sanitization. This demonstrates how attackers can embed phishing forms inside legitimate websites and trick users into entering sensitive credentials.

Day 7 – Command Injection (Remote Code Execution Concept)

In the Command Injection lab, I entered 127.0.0.1 & whoami into the input field. The application executed both the intended ping command and the injected system command. The output revealed the server’s operating system user, demonstrating remote command execution. This shows how unsanitized input can lead to full server compromise if not properly secured.

During Week 2, I gained hands-on experience with major web vulnerabilities including SQL Injection, Cross-Site Scripting (Reflected and Stored), and Command Injection. Through practical testing in DVWA, I observed how improper input validation and lack of output sanitization can lead to severe security risks such as data leakage, session hijacking, phishing attacks, and remote command execution. This week strengthened my understanding of how attackers exploit web applications and emphasized the importance of secure coding practices.
